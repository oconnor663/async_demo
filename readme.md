- regular program calling foo() and bar() in series
- use threads to make it parallel
  - first with std::thread::spawn, then with rayon::join
- Tokio version using futures::future::join
  - using std::thread::sleep ruins the concurrency
  - this is how we know it was running on one thread before
- write our own sleep
  - no wakeup hangs Tokio forever
  - wakeup threads fix Tokio but defeat the purpose
  - write a custom polling loop with a busy sleep
  - use a thread local and a real sleep
- write our own foo/bar future
  - If we eagerly return Pending on the first poll, we never wake up.
  - Why not print in the constructor and get rid of is_start?
    - That's not what `async fn` does, because `async fn` needs the future to
      be pinned.
- write our own join
- change join() to first(), cancellation
- follow-up topics
  - tasks
  - Pin
  - real IO
