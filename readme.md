- regular program calling work() in series
- use threads to make it parallel
  - first with std::thread::spawn, then with rayon::join
  - try spawning ~20k threads (~500 on the Playgroud)
- Tokio version using futures::future::join
  - using std::thread::sleep ruins the concurrency
  - this is how we know it was running on one thread before
  - this version scales to millions of jobs
- write our own sleep
  - no wakeup hangs Tokio forever
  - spamming wake() works but burns the CPU
  - wakeup threads fix Tokio but defeat the purpose
  - use a thread local and custom block_on()
- write our own work future
- write our own join
- follow-up topics
  - timeout, cancellation
  - futures::future::join_all creates its own Waker
  - tasks
  - Pin
  - real IO
