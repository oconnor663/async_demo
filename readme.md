- regular program calling work() in series
- use threads to make it parallel
  - first with std::thread::spawn, then with rayon::scope
  - try spawning ~20k threads (~500 on the Playgroud)
- Tokio version using futures::future::join_all
  - using std::thread::sleep ruins the concurrency
  - this is how we know it was running on one thread before
  - this version scales to millions of jobs
- write our own sleep
  - no wakeup hangs Tokio forever
  - spamming wake() works but burns the CPU
  - use a thread local and a BTreeMap of wakers
    - If the main loop is already awake, why do we need to call wake()? Because
      futures::future::JoinAll substitutes its own context.
- write our own work future
- write our own join_all
- follow-up topics
  - timeout, cancellation
  - tasks
  - recursion
  - Pin
  - real IO
